## Full text queries

全文索引查询能够搜索分析过的文本字段。使用字段建立索引时同样的分析器处理查询的字符串。

全文索引查询有：

- `intervals` 查询

  能够控制匹配项的顺序和接近程序级别细粒度的全文索引查询。

- `match` 查询

  全文索引查询的标准查询方式，能够模糊匹配和短语或邻近查询。

- `match_bool_prefix` 查询

  创建一个布尔查询，将每一项进行 `term` （精确）查询；最后一项作为前缀查询进行匹配。

- `match_phrase` 查询

  类似于 `match` 查询，但是匹配准确的短语或接近的单词匹配。

- `match_phrase_prefix` 查询

  类似于 `match_phrase` 查询，但对最后一个词进行通配查询。

- `multi_match` 查询

  查询多字段版本的 `match` 查询。

- `combined_fields` 查询

  匹配多个字段，就像它们被索引到一个组合字段一样。

- `query_string` 查询

  支持 Lucene 查询字符串语法，可以在单个查询字符串中通过 AND|OR|NOT 条件和多字段（multi-field）查询。仅供专家使用。

- `simple_query_string` 查询

  适合直接暴露给用户得更简单、更健壮的 `query_string` 语法版本。

### Intervals query

返回匹配顺序和匹配项接近的文档。

`intervals` 查询使用一小组定义构成的匹配规则，然后将这些规则应用于指定 `field` 的项目。

这些定义产生了跨越文本中项的最小间隔序列。这些间隔可以被父节点进一步组合和筛选。

#### Example request

以下 `intervals` 查询返回字段 `my_text` 中包含没有间隙的 `my favorite food`，跟着 `hot water` 或 `cold porridge` 的文档。

字段 `my_text` 中 `my favorite food is cold porridge` 可以匹配，但 `when it's cold my favorite food is porridge` 不匹配。

```
POST /_search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "all_of" : {
          "ordered" : true,
          "intervals" : [
            {
              "match" : {
                "query" : "my favorite food",
                "max_gaps" : 0,
                "ordered" : true
              }
            },
            {
              "any_of" : {
                "intervals" : [
                  { "match" : { "query" : "hot water" } },
                  { "match" : { "query" : "cold porridge" } }
                ]
              }
            }
          ]
        }
      }
    }
  }
}
```

#### Top-level parameters for `intervals`

- `<field>`

  （必填，规则对象）想要搜索的字段。

  该参数的值为规则对象，用来基于匹配项、顺序和接近程度来匹配文档。

  有效的规则包括：

  - `match`
  - `prefix`
  - `wildcard`
  - `fuzzy`
  - `all_of`
  - `any_of`

#### `match` rule parameters

`match` 规则匹配分析过的文本。

- `query`

  （必填，字符串）提供的 `<field>` 中想要找到的文本。

  *会按照分析器分词。*

- `max_gaps`

  （可选，整型）匹配项之间的最大位置数量。超过该数量则不算匹配。默认值 `-1`。

  未指定或者值为 `-1`，则匹配上没有限制。如果设置为 `0`，则这些项必须相邻出现。

  *当 `query` 是多个单词时，能够夹在它们中间的非匹配单词/项的数量。*

- `ordered`

  （可选，布尔类型）为 `true` 时，匹配项必须按照它们指定的顺序出现。默认值 `false`。

  *是否严格按照 `query` 中单词的顺序进行匹配，就算中间有其它不匹配单词。*

- `analyzer`

  （可选，字符串）查询中分析项目使用的分析器。默认是顶层（top-level）`field` 的分析器。

- `filter`

  （可选，间隔筛选规则对象）可选的间隔筛选器。

- `use_field`

  （可选，字符串）若指定，将匹配该字段的间隔，而不是顶层的 `<field>`。项目使用来自该字段的搜索分析器进行分析。这使得可以搜索多个字段，就像它们在同一个字段中。例如，可以将相同的文本索引到有词根和无词根的字段中，并在无词根的字段搜索有词根的文档。

#### `prefix` rule parameters

`prefix` （前缀）规格匹配以指定字符集开头的词汇。最多可以匹配 128 个词。超过128 个词，`es` 会返回错误。可以通过字段映射 `index-prefixes` 选项修改这个限制。

- `prefix`

  （必填，字符串）在顶层 `<field>` 中查找词汇的字符集开头。

- `analyzer`

  （可选，字符串）用于规范化前缀的分析器。默认为顶层 `<field>` 的分析器。

- `use_field`

  （可选，字符串）若指定，将匹配该字段的间隔，而不是顶层的 `<field>`。
  
  除非指定了单独的分析器 `analyzer`，`prefix` 使用本字段的搜索分析器规范化。

#### `wildcard` rule parameters

`wildcard` （通配）规则匹配使用通配符模式。最多匹配 128 个词。超过128 个词，`es` 会返回错误。

- `pattern`

  （必填，字符串）寻找匹配项的通配符模式。

  参数支持两种通配符运算符：

  - `?`，匹配单个字符
  - `*`，匹配 0 个或多个字符，包含一个空字符

  > 应避免查询以 `*` 或 `?` 开头的通配符模式。这会增加匹配项所需的迭代次数并降低搜索性能。

- `analyzer`

  （可选，字符串）用于规范化模式。默认为顶层 `<field>` 的分析器。

- `use_field`

  （可选，字符串）若指定，将匹配该字段的间隔，而不是顶层的 `<field>`。

  除非指定了单独的分析器 `analyzer`，`prefix` 使用本字段的搜索分析器规范化。

#### `fuzzy` rule parameters

`fuzzy`（模糊）规则匹配相似的项，模糊程度是 `fuzziness` 模糊度定义的距离内。多可以匹配 128 个词。超过128 个词，`es` 会返回错误。

- `term`

  （必填，字符串）匹配项。

- `prefix_length`

  （可选，整型）创建扩展时保持不变的起始字符数。默认为 `0`。

- `transpositions`

  （可选，布尔）指示编辑是否包含两个相邻字符的换位（ab->ba）。默认为 `true`。

- `fuzziness`

  （可选，字符串）匹配允许最大的编辑距离。查看 Fuzziness 中有效的值。默认为 `auto`。

- `analyzer`

  （可选，字符串）用于规范化 `term`。默认为顶层 `<field>` 的分析器。

- `use_field`

  （可选，字符串）若指定，将匹配该字段的间隔，而不是顶层的 `<field>`。

  除非指定了单独的分析器 `analyzer`，`prefix` 使用本字段的搜索分析器规范化。

#### `all_of` rule parameters

`all_of` 规则返回包含多个规则组合匹配的项。

- `intervals`

  （必填，规则数组对象）组合的规则数组。文档必须匹配所有的规则。

- `max_gaps`

  （可选，整型）匹配项之间的最大位置数量。超过改数量则不算匹配。默认值 `-1`。

  未指定或者值为 `-1`，则匹配上没有限制。如果设置为 `0`，则这些项必须相邻出现。

- `ordered`

  （可选，布尔）若 `true`，规则产生的间隔应该按照指定的顺序出现。默认 `false`。

- `filter`

  （可选，间隔筛选规则对象）返回间隔的筛选规则。

#### `any_of` rule parameters

`any_of` 规则返回由它的任何子规则匹配的间隔。

- `intervals`

  （必填，规则数组对象）组合的规则数组。

- `filter`

  （可选，间隔筛选规则对象）返回间隔的筛选规则。

#### `filter` rule parameters

`filter` 规则根据查询返回间隙。

*注意是作用于匹配到的间隙之间进行筛选。例如 `d a b c e` 中匹配  `a c`，筛选器是作用于匹配到的 `a` 和 `c` 之间的作用域（`c a` 也一样）。*

- `after`

  （可选，查询对象）作用于返回的间隔，其后有 `filter` 规则中的间隔。

- `before`

  （可选，查询对象）作用于返回的间隔，其前有 `filter` 规则中的间隔。

- `contained_by`

  （可选，查询对象）作用于返回的间隔，其包含于 `filter` 规则中的间隔。

  *与其它的不同，其它的筛选是作用在查询返回的匹配的间隔上；这个是用 `contained_by` 在文档上查询到的间隔来匹配查询内容；例子 `Minimization` 的第一个例子就是这种情况。*

- `containing`

  （可选，查询对象）作用于返回的间隔，其中包含 `filter` 规则中的间隔。

- `not_contained_by`

  （可选，查询对象）作用于返回的间隔，其不包含于 `filter` 规则中的间隔。

- `not_containing`

  （可选，查询对象）作用于返回的间隔，其中不包含 `filter` 规则中的间隔。

- `not_overlapping`

  （可选，查询对象）作用于返回的间隔，其与 `filter` 规则中的间隔不重合。

- `overlapping`

  （可选，查询对象）作用于返回的间隔，其与 `filter` 规则中的间隔重合。

- `script`

  （可选，脚本对象）脚本应用于返回的匹配文档。脚本必须返回一个布尔类型值，`true` 或 `false`。

#### Notes

##### Filter example

下面搜索包含了一个 `filter` 规则。返回包含 `hot` 和 `porridge` 的文档，中间间隔不超过 10 个单词，并且之间不包含 `salty`：

```
POST /_search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "match" : {
          "query" : "hot porridge",
          "max_gaps" : 10,
          "filter" : {
            "not_containing" : {
              "match" : {
                "query" : "salty"
              }
            }
          }
        }
      }
    }
  }
}
```

##### Script filters

可以使用脚本基于起始位置、结束位置或者内部的间隔数量删选间隔。下方 `filter` 脚本使用 `interval` 变量调用 `start`、`end` 和 `gaps` 方法：

```
POST /_search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "match" : {
          "query" : "hot porridge",
          "filter" : {
            "script" : {
              "source" : "interval.start > 10 && interval.end < 20 && interval.gaps == 0"
            }
          }
        }
      }
    }
  }
}
```

##### Minimization

间隔查询总是返回查询匹配到的最小间隔，确保查询花费的是线性时间。这有时产生意外的结果，特别是使用 `max_gaps` 限制或筛选时。例如下方查询搜索包含于词组 `hot` 和 `porridge` 之间的 `salty`：

```
POST /_search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "match" : {
          "query" : "salty",
          "filter" : {
            "contained_by" : {
              "match" : {
                "query" : "hot porridge"
              }
            }
          }
        }
      }
    }
  }
}
```

包含短语 `hot porridge is salty porridge` 的文档不匹配查询，因为匹配查询 `hot porridge` 返回的间隔只包含这个文档中的初始两项，而这些与包含 `salty` 的间隔没有重叠的部分。

另外需要知道的限制是当使用 `any_of` 规则时，子规则包含重叠。特别地，当其中的一个规则完全是另一个前缀时，那么更长的那个规则将永远不会匹配上；与 `max_gaps` 组合使用时，甚至会产生意外的结果。考虑以下查询，搜索 `the` 紧跟着 `big` 或 `big bad` 再接着是 `wolf`：

```
POST /_search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "all_of" : {
          "intervals" : [
            { "match" : { "query" : "the" } },
            { "any_of" : {
                "intervals" : [
                    { "match" : { "query" : "big" } },
                    { "match" : { "query" : "big bad" } }
                ] } },
            { "match" : { "query" : "wolf" } }
          ],
          "max_gaps" : 0,
          "ordered" : true
        }
      }
    }
  }
}
```

万万没想到的是，这个查询没有匹配文档 `the big bad wolf`，由于中间的 `any_of` 规则只产生 `big` 的间隔——`big bad` 的间隔比 `big` 要长，并且开始于同一位置，被最小化了。在这些情况下，最好重写查询，所有都选项都在顶层显式地给出：

```
POST /_search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "any_of" : {
          "intervals" : [
            { "match" : {
                "query" : "the big bad wolf",
                "ordered" : true,
                "max_gaps" : 0 } },
            { "match" : {
                "query" : "the big wolf",
                "ordered" : true,
                "max_gaps" : 0 } }
           ]
        }
      }
    }
  }
}
```

### Match query

返回匹配提供的文本、数组、日期或者布尔值的文档。提供的文本将先分析再做匹配。

`match` 查询是执行全文搜索的的标准查询，包含模糊查询的选项。

#### Example request

```
GET /_search
{
  "query": {
    "match": {
      "message": {
        "query": "this is a test"
      }
    }
  }
}
```

#### Top-level parameters for `match`

- `<field>`

  （必填，规则对象）想要搜索的字段。

#### Parameters for `<field>`

- `query`

  （必填）想要在提供的 `<field>` 中查找的文本、数字、布尔值或者日期。

  `match` 查询在执行搜索前会将任何提供的文本进行分析。这意味着 `match` 查询可以通过分析了的分词搜索 `text` 字段而不是精确匹配。

- `analyzer`

  （可选，字符串）将 `query` 值转化成分词的分析器。默认为 `<field>` 映射的索引时分析器。如果没有指定分析器，使用索引的默认分析器。

- `auto_generate_synonyms_phrase_query`

  如果为 `true`，匹配的短语查询将为多词同义词自动创建。默认 `true`。

- `fuzziness`

  （可选，字符串）匹配允许的最大编辑距离。

- `max_expansions`

  （可选，整型）查询可以扩展到的最大项目/词数。

- `prefix_length`

  （可选，整型）模糊搜索时保持不变的起始字符数。默认为 `0`。

- `fuzzy_transpositions`

  （可选，布尔）如果 `true`，编辑是否包含两个相邻字符的换位（ab->ba）。默认为 `true`。

- `fuzzy_rewrite`

  （可选，字符串）重写查询的方法。

  如果 `fuzziness` 参数不为 `0`，`match` 查询的 `fuzzy_rewrite` 方法默认使用 `top_terms_blended_freqs_${max_expansions}`。

- `lenient`

  如果为 `true`，格式错误，例如数字类型字段使用文本 `query` 值的错误将被忽略。默认 `false`。

- `operator`

  （可选，字符串）用于说明 `query` 值中文本的布尔逻辑。有效值：

  - `OR`（默认）

    例如 `capital of Hungary` 的 `query` 值被解释为 `capital OR of OR Hungary`。

  - `AND`

    例如 `captial of Hungary` 的 `query` 值被解释为 `capital AND of AND Hungary`。

- `minimum_should_match`

  （可选，字符串）必须要与返回的文档匹配的最小子句数。

- `zero_terms_query`

  （可选，字符串）表明如果 `analyzer` 移除了所有分词，是否不返回文档，例如使用 `stop` 筛选时。有效值有：

  - `none`（默认）

    如果 `analyzer` 移除了所有分词，将不返回文档。

  - `all`

    类似于 `match_all` 查询，返回所有文档。

#### Notes

##### Short request example

结合 `<field>` 和 `query` 参数简化匹配查询的语法。

```
GET /_search
{
  "query": {
    "match": {
      "message": "this is a test"
    }
  }
}
```

##### How the match query works

`match` 查询是 `boolean` 类型。意味着对提供的文本进行分析，分析过程根据提供的文本构造一个布尔查询。`operator` 参数通过设置为 `or` 或 `and` 来控制布尔子句（默认为 `or`）。可选的 `should` 子句匹配的最小数可以通过 `minimum_should_match` 参数设定。

这是一个 `operator` 参数的例子：

```
GET /_search
{
  "query": {
    "match": {
      "message": {
        "query": "this is a test",
        "operator": "and"
      }
    }
  }
}
```

`analyzer` 用来控制对文本执行分析的分析器。它默认为字段显式的映射定义，或默认的搜索分析器。

`lenient` 参数设置为 `true` 可以忽略数据类型不匹配造成的异常，例如尝试通过文本查询字符串去查询数据类型字段。默认为 `false`。

##### Fuzziness in the match query

`fuzziness` 允许基于被查询字段的类型进行模糊匹配。

`prefix_length` 和 `max_expansions` 在这种情况用来控制模糊搜索进程。如果设置了模糊搜索选项，`top_terms_blended_freqs_${max_expansions}` 将作为重写方法，`fuzzy_rewrite` 参数可以控制查询是如何重写的。

模糊搜索换位（`ab`->`ba`）默认开启，可以通过将 `fuzzy_transpositions` 设置为 `false` 关闭。

> 模糊匹配不支持同义词的项或者分析进程在同一个位置产生多个分词的情况。在底层，这些项被扩展为一个特殊的同义词查询，混合着频率，这不支持模糊扩展。

```
GET /_search
{
  "query": {
    "match": {
      "message": {
        "query": "this is a testt",
        "fuzziness": "AUTO"
      }
    }
  }
}
```

##### Zero terms query

如果分析器就像 `stop` 筛选器一样，将所有分词都删除，默认的结果没有文档会匹配。`zero_terms_query` 选项可以改变这一行为。接受值 `none`（默认）或者 `all` 对应 `match_all` 查询。

*停止分析器会将所有停用词（stop words）在索引时全部删除。这是，像下方查询中全部都是停止词，一过滤，就什么也没有了。`zero_terms_query` 就是为了解决这个问题。*

```
GET /_search
{
  "query": {
    "match": {
      "message": {
        "query": "to be or not to be",
        "operator": "and",
        "zero_terms_query": "all"
      }
    }
  }
}
```

##### Synonyms

`match` 查询支持通过同义词图表分词过滤器（Synonym graph token filter）多项同义词扩展。当使用该筛选器，分析器为每个多项同义词创建一个短语查询。例如同义词：`"ny, new york"` 会产生：

`(ny OR ("new york"))`

也可以用 ”与“ 来匹配多个同义词：

```
GET /_search
{
   "query": {
       "match" : {
           "message": {
               "query" : "ny city",
               "auto_generate_synonyms_phrase_query" : false
           }
       }
   }
}
```

上方例子创建一个布尔查询：

`(ny OR (new AND york)) city`

匹配有 `ny` 或者 “与”  `new AND york` 的文档。默认 `auto_generate_synonyms_phrase_query` 设置为 `true`。

### Match boolean prefix query

`match_bool_prefix` 查询分析输入，对输入项构建一个 `bool` 查询。除了最后一项，每一项都是用 `term` 查询。最后一项使用 `prefix` 查询。`match_bool_prefix` 查询例如

```
GET /_search
{
  "query": {
    "match_bool_prefix" : {
      "message" : "quick brown f"
    }
  }
}
```

分析对 `quick`、`brown` 和 `f` 产生类似于如下的 `bool` 查询

```
GET /_search
{
  "query": {
    "bool" : {
      "should": [
        { "term": { "message": "quick" }},
        { "term": { "message": "brown" }},
        { "prefix": { "message": "f"}}
      ]
    }
  }
}

```

`match_bool_prefix` 查询与 `match_phrase_prefix` 最重要的差别，`match_phrase_prefix` 查询将项目作为短语匹配，而 `match_bool_prefix` 查询能够在任何位置匹配项。上方的 `match_bool_prefix` 查询例子可以匹配包含 `quick brown fox` 的字段，同样可以匹配 `brown fox quick`。除此以外还可以匹配任何包含出现在任何位置的 `quick`、`brown` 和以 `f` 开头的字段。

#### Parameters

默认，`match_bool_prefix` 查询的输入文本会使用查询字段的映射分析器分析。使用 `analyzer` 参数可以设置为不同的搜索分析器。

```
GET /_search
{
  "query": {
    "match_bool_prefix": {
      "message": {
        "query": "quick brown f",
        "analyzer": "keyword"
      }
    }
  }
}
```

`match_bool_prefix` 查询支持正如 `match` 查询描述的 `minimum_should_match` 和 `operator` 参数，将设置运用于构建的 `bool` 查询。大多数情况下构建的 `bool` 查询的子句数量与分析查询文本产生的分词数一样。

`fuzziness`、`prefix_length`、`max_expansions`、`fuzzy_transpositions` 和 `fuzzy_rewrite` 参数可以运用于除了最后一项外所有项构成的 `term` 子查询。它们对最后一个词构造的前缀查询没有任何影响。

### Match phrase query

`match_phrase` 查询分析文本，并根据分析的文本创建一个短语查询。

```
GET /_search
{
  "query": {
    "match_phrase": {
      "message": "this is a test"
    }
  }
}
```

短语查询根据可以设置的 `slop`（默认为 0）匹配任何顺序的项。交换顺序的项的 `slop` 为 2。

`slop` 参数告诉 `match_phrase` 查询词条相隔多远时仍然能将文档视为匹配。相隔多远的意思是为了让查询和文档匹配需要移动词条多少次。

为了让查询 `quick fox` 能匹配一个包含 `quick brown fox` 的文档，需要 `slop` 的值为 `1`：

```
		Pos 1		Pos 2		Pos3
---------------------------------------
Doc:	quick		brown		fox
---------------------------------------
Query:	quick		fox
Slop 1: quick				⇢	fox
```

尽管在使用了 `slop` 短语匹配中所有的单词都需要出现，但是这些单词也不必为了匹配而按相同的序列排列。有了足够大的 `slop` 值，单词就能按照任意顺序排列了。

为了使查询 `fox quick` 匹配我们的文档，我们需要 `slop` 的值为 `3`：

```
		Pos 1		Pos 2		Pos3
---------------------------------------
Doc:	quick		brown		fox
---------------------------------------
Query:	fox			quick
Slop 1: fox|quick
Slop 2: quick	⇢	fox
Slop 3: quick				⇢	fox
```

注意 `fox` 和 `quick` 在 `Slop 1` 这步中占据相同的位置。因此将 `fox quick` 转换顺序成 `quick fox` 需要两步，或者值为 `2` 的 `slop`。

`analyzer` 可以控制对文本执行分析进程所使用的分析器。默认为字段显式映射定义的分析器，或是默认分析器，例如：

```
GET /_search
{
  "query": {
    "match_phrase": {
      "message": {
        "query": "this is a test",
        "analyzer": "my_analyzer"
      }
    }
  }
}
```

该查询同样可以使用 `match` 查询中说明过的 `zero_terms_query`。

### Match phrase prefix query

